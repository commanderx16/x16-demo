;Petdraw (Commander X16 version)
;by David Murray 2019
;dfwgreencars@gmail.com


*=$0801               ;START ADDRESS IS $0801
VERA_INC=$9F22
VERA_HI=$9F21
VERA_LO=$9F20
VERA_RW=$9F23

BASIC:	!BYTE $0B,$08,$01,$00,$9E,$32,$30,$36,$31,$00,$00,$00
	;Adds BASIC line:  1 SYS 2061
INIT1:
	JSR	SWBANK2

	JSR	SET_MODE

INIT2:
	JSR	CLEAR_SCREEN
	LDA	#00	;SET INITIAL VALUES
	STA	XLOC
	STA	YLOC
	LDA	#01
	STA	PCOL
	LDA	#40
	STA	SCR_SIZE_X
	LDA	#30
	STA SCR_SIZE_Y
	JSR	MAIN_CURSOR_PLOT
	JSR	HELP_SCREEN
	
MAIN_DRAW_SCREEN:

MAIN_DRAW_KEYWAIT:
	JSR	$FFE4
	CMP	#$00
	BEQ	MAIN_DRAW_KEYWAIT
	CMP	#$91	;CURSOR UP
	BNE	MDK01
	JSR	MAIN_KEY_UP
	JMP	MAIN_DRAW_KEYWAIT
MDK01:
	CMP	#$11	;CURSOR DOWN
	BNE	MDK02
	JSR	MAIN_KEY_DOWN
	JMP	MAIN_DRAW_KEYWAIT
MDK02:	
	CMP	#$9D	;CURSOR LEFT
	BNE MDK03
	JSR	MAIN_KEY_LEFT
	JMP	MAIN_DRAW_KEYWAIT
MDK03:
	CMP	#$1D	;CURSOR RIGHT
	BNE MDK04
	JSR	MAIN_KEY_RIGHT
	JMP	MAIN_DRAW_KEYWAIT
MDK04:
	CMP	#$0D	;RETURN
	BNE MDK05
	JSR	CHARACTER_SELECT_SCREEN
	JMP	MAIN_DRAW_KEYWAIT
MDK05:
	CMP	#32		;SPACE BAR
	BNE	MDK06
	JSR	MAIN_CURSOR_UNPLOT
	LDA	SELCOL
	STA PCOL
	JSR	PLOTCHAR
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK06:
	CMP	#$48	;H KEY
	BNE	MDK07
	JSR	HELP_SCREEN
	JMP	MAIN_DRAW_KEYWAIT
MDK07:
	CMP	#137	;F2-KEY (PIXEL DRAW MODE)
	BNE	MDK08
	JMP	PIXEL_DRAW_SCREEN
MDK08:
	CMP	#$47	;G-key	
	BNE	MDK09:
	JSR	MAIN_CURSOR_UNPLOT
	JSR	GETCHAR
	LDA	PCOL
	STA	SELCOL
	JSR MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT	
MDK09:
	CMP	#$1F	;BLUE
	BNE	MDK10
	LDA	#06		;COLOR BLUE
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK10:
	CMP	#$05	;WHITE
	BNE	MDK11
	LDA	#01		;COLOR WHITE
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK11:
	CMP	#$1C	;RED
	BNE	MDK12
	LDA	#02		;COLOR RED
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK12:
	CMP	#138	;F4-KEY
	BNE	MDK13
	JSR	MAIN_CURSOR_UNPLOT
	JSR	COLOR_SCREEN
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK13:
	CMP	#134	;F3-KEY (TYPING MODE)
	BNE	MDK14
	JMP	TYPE_MODE
MDK14:
	CMP	#$14	;BACKSPACE
	BNE	MDK15	
	JSR	MAIN_CURSOR_UNPLOT
	LDA	#32
	STA	PCHAR
	JSR	PLOTCHAR
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK15:
	CMP	#$90	;BLACK
	BNE	MDK16
	LDA	#00		;COLOR BLACK
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK16:
	CMP	#$9F	;CYAN
	BNE	MDK17
	LDA	#03		;COLOR CYAN
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK17:
	CMP	#$9C	;PURPLE
	BNE	MDK18
	LDA	#04		;COLOR PURPLE
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK18:
	CMP	#$1E	;GREEN
	BNE	MDK19
	LDA	#05		;COLOR GREEN
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK19:
	CMP	#$9E	;YELLOW
	BNE	MDK20
	LDA	#07		;COLOR YELLOW
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK20:
	CMP	#$81	;ORANGE
	BNE	MDK21
	LDA	#08		;COLOR ORANGE
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK21:
	CMP	#$95	;BROWN
	BNE	MDK22
	LDA	#09		;COLOR BROWN
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK22:
	CMP	#$96	;LIGHT RED
	BNE	MDK23
	LDA	#10		;COLOR LIGHT RED
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK23:
	CMP	#$97	;DARK GRAY
	BNE	MDK24
	LDA	#11		;COLOR DARK GRAY
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK24:
	CMP	#$98	;GRAY
	BNE	MDK25
	LDA	#12		;COLOR GRAY
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK25:
	CMP	#$99	;LIGHT GREEN
	BNE	MDK26
	LDA	#13		;COLOR LIGHT GREEN
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK26:
	CMP	#$9A	;LIGHT BLUE
	BNE	MDK27
	LDA	#14		;COLOR LIGHT BLUE
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK27:
	CMP	#$9B	;LIGHT GRAY
	BNE	MDK28
	LDA	#15		;COLOR LIGHT GRAY
	JSR	KEYS_SET_COLOR
	JMP	MAIN_DRAW_KEYWAIT
MDK28:
	CMP	#135	;F5 KEY (SETUP)
	BNE MDK29
	JSR	SETUP_MENU
	JMP	MAIN_DRAW_KEYWAIT
MDK29:	
	CMP	#$43	;C-KEY
	BNE	MDK30
	JSR	PASTE_COLOR_ONLY
	JMP	MAIN_DRAW_KEYWAIT
MDK30:
	CMP	#139	;F6 key (LOAD/SAVE)
	BNE	MDK31
	JSR	MAIN_CURSOR_UNPLOT
	JSR	LOAD_SAVE_MENU
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT	
MDK31:	
	CMP	#$93	;CLR-SCREEN
	BNE	MDK32:
	JSR	CLEAR_SCREEN
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK32:
	CMP	#$D5	;SHIFT-U
	BNE	MDK33
	JSR	MAIN_CURSOR_UNPLOT
	JSR	SHIFT_LINE_UP
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK33:	
	CMP	#$C4	;SHIFT-D
	BNE	MDK34
	JSR	MAIN_CURSOR_UNPLOT
	JSR	SHIFT_LINE_DOWN
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK34:
	CMP	#$CC	;SHIFT-L
	BNE	MDK35
	JSR	MAIN_CURSOR_UNPLOT
	JSR	SHIFT_LINE_LEFT
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK35:
	CMP	#$D2	;SHIFT-R
	BNE	MDK36
	JSR	MAIN_CURSOR_UNPLOT
	JSR	SHIFT_LINE_RIGHT
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_KEYWAIT
MDK36:
	JMP	MAIN_DRAW_KEYWAIT

SHIFT_LINE_RIGHT:
	LDA	SCR_SIZE_X
	SEC
	SBC	#1
	STA	XTEMP
	LDA	#%00010000	;INCREMENT SET TO 1
	STA	VERA_INC
	;FIRST GRAB RIGHT CHARACTER+COLOR FOR STORAGE
	LDA	YLOC
	STA	VERA_HI
	LDA	SCR_SIZE_X
	SEC
	SBC	#1
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	SHIFT_TEMP1
	LDA	VERA_RW
	STA	SHIFT_TEMP2
SHRT02:	
	;NEXT GET BYTE FROM COLUMN TO LEFT
	LDA	XTEMP
	SEC
	SBC	#1
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	CHRTEMP
	LDA	VERA_RW
	STA	COLTEMP
	;NOW STORE TO CURRENT COLUMN
	LDA	XTEMP
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	CHRTEMP
	STA	VERA_RW
	LDA	COLTEMP
	STA	VERA_RW
	;NOW MOVE TO LEFT
	DEC	XTEMP
	LDA	XTEMP
	CMP	#0
	BNE	SHRT02
	;NOW PLACE TEMP CHAR AT LEFT OF SCREEN
	LDA	0
	STA	VERA_LO
	LDA	SHIFT_TEMP1
	STA	VERA_RW
	LDA	SHIFT_TEMP2
	STA	VERA_RW
	RTS

SHIFT_LINE_LEFT:
	LDA	#0
	STA	XTEMP
	LDA	#%00010000	;INCREMENT SET TO 1
	STA	VERA_INC
	;FIRST GRAB LEFT CHARACTER+COLOR FOR STORAGE
	LDA	YLOC
	STA	VERA_HI
	LDA	#0
	STA	VERA_LO
	LDA	VERA_RW
	STA	SHIFT_TEMP1
	LDA	VERA_RW
	STA	SHIFT_TEMP2
SHLF02:	
	;NEXT GET BYTE FROM COLUMN TO RIGHT
	LDA	XTEMP
	CLC
	ADC	#1
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	CHRTEMP
	LDA	VERA_RW
	STA	COLTEMP
	;NOW STORE TO CURRENT COLUMN
	LDA	XTEMP
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	CHRTEMP
	STA	VERA_RW
	LDA	COLTEMP
	STA	VERA_RW
	;NOW MOVE TO RIGHT
	INC	XTEMP
	LDA	SCR_SIZE_X
	SEC
	SBC	#1
	CMP	XTEMP
	BNE	SHLF02
	;NOW PLACE TEMP CHAR AT RIGHT OF SCREEN
	LDA	SCR_SIZE_X
	SEC
	SBC	#1
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	SHIFT_TEMP1
	STA	VERA_RW
	LDA	SHIFT_TEMP2
	STA	VERA_RW
	RTS

SHIFT_LINE_UP:
	LDA	#0
	STA	YTEMP
	LDA	#%00010000	;INCREMENT SET TO 1
	STA	VERA_INC
	;FIRST GRAB TOP CHARACTER+COLOR FOR STORAGE
	LDA	#0
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	SHIFT_TEMP1
	LDA	VERA_RW
	STA	SHIFT_TEMP2
SHUP02:	
	;NEXT GET BYTE FROM ROW BELOW
	LDA	YTEMP
	CLC
	ADC	#1
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	CHRTEMP
	LDA	VERA_RW
	STA	COLTEMP
	;NOW STORE TO CURRENT ROW
	LDA	YTEMP
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	CHRTEMP
	STA	VERA_RW
	LDA	COLTEMP
	STA	VERA_RW
	;NOW MOVE DOWN
	INC	YTEMP
	LDA	SCR_SIZE_Y
	SEC
	SBC	#1
	CMP	YTEMP
	BNE	SHUP02
	;NOW PLACE TEMP CHAR AT BOTTOM OF SCREEN
	LDA	SCR_SIZE_Y
	SEC
	SBC	#1
	STA	VERA_HI	
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	SHIFT_TEMP1
	STA	VERA_RW
	LDA	SHIFT_TEMP2
	STA	VERA_RW
	RTS

SHIFT_LINE_DOWN:
	LDA	SCR_SIZE_Y
	SEC
	SBC	#1
	STA	YTEMP
	LDA	#%00010000	;INCREMENT SET TO 1
	STA	VERA_INC
	;FIRST GRAB BOTTOM CHARACTER+COLOR FOR STORAGE
	LDA	SCR_SIZE_Y
	SEC
	SBC	#1
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	SHIFT_TEMP1
	LDA	VERA_RW
	STA	SHIFT_TEMP2
SHDN02:	
	;NEXT GET BYTE FROM ROW ABOVE
	LDA	YTEMP
	SEC
	SBC	#1
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	CHRTEMP
	LDA	VERA_RW
	STA	COLTEMP
	;NOW STORE TO CURRENT ROW
	LDA	YTEMP
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	CHRTEMP
	STA	VERA_RW
	LDA	COLTEMP
	STA	VERA_RW
	;NOW MOVE UP
	DEC	YTEMP
	LDA	YTEMP
	CMP	0
	BNE	SHDN02
	;NOW PLACE TEMP CHAR AT TOP OF SCREEN
	LDA	#0
	STA	VERA_HI	
	LDA	XLOC
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	SHIFT_TEMP1
	STA	VERA_RW
	LDA	SHIFT_TEMP2
	STA	VERA_RW
	RTS

PASTE_COLOR_ONLY:
	LDA	SELCOL
	STA	CRSR_OLD_COL
	JSR	MAIN_CURSOR_UNPLOT
	JSR	MAIN_CURSOR_PLOT
	RTS

KEYS_SET_COLOR:
	AND	#%00001111
	TAX
	LDA	SELCOL
	AND	#%11110000
	STA	SELCOL
	TXA
	ORA	SELCOL
	STA	SELCOL
	RTS

MAIN_KEY_UP:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	YLOC
	CMP	#0
	BEQ	MKU1
	DEC	YLOC
MKU1:
	JSR	MAIN_CURSOR_PLOT
	RTS

MAIN_KEY_DOWN:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	YLOC
	CLC
	ADC	#01
	CMP	SCR_SIZE_Y
	BEQ	MKD1
	INC	YLOC
MKD1:
	JSR	MAIN_CURSOR_PLOT
	RTS

MAIN_KEY_LEFT:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	XLOC
	CMP	#0
	BEQ	MKU1
	DEC	XLOC
MKL1:
	JSR	MAIN_CURSOR_PLOT
	RTS

MAIN_KEY_RIGHT:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	XLOC
	CLC
	ADC	#01
	CMP	SCR_SIZE_X
	BEQ	MKR1
	INC	XLOC
MKR1:
	JSR	MAIN_CURSOR_PLOT
	RTS

;currently the cursor plot just inverts the color, but
;I plan to make it more intersting later.

MAIN_CURSOR_PLOT:
	LDA	#00
	STA	VERA_INC	;INCREMENT SET TO ZERO
	LDA	YLOC
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	CLC
	ADC	#01
	STA	VERA_LO
	LDA	VERA_RW	;GET COLOR
	STA	CRSR_OLD_COL
	STA CHRTEMP
	ASL			;INVERT COLORS
	ASL
	ASL
	ASL
	LSR	CHRTEMP
	LSR	CHRTEMP
	LSR	CHRTEMP
	LSR	CHRTEMP
	ORA	CHRTEMP
	STA	VERA_RW
	RTS

MAIN_CURSOR_UNPLOT:
	LDA	#00
	STA	VERA_INC	;INCREMENT SET TO ZERO
	LDA	YLOC
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULT BY 2
	CLC
	ADC	#01
	STA	VERA_LO
	LDA	CRSR_OLD_COL
	STA	VERA_RW
	RTS

CHARACTER_SELECT_SCREEN:
	JSR	MAIN_CURSOR_UNPLOT
	JSR	COPY_SCREEN_TO_BUFFER
	JSR	SET40
	
;This routine is a bit unique because I had to design the
;character pick screen from the C64 version of PetDraw which
;stores the data in a very different way.  So this routine
;converts it while simultaneously displays it on screen.	
	
CSS01:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDY	#00
	STY	VERA_HI
	STY	VERA_LO		;SET STARTING POSITION
	LDA	#<CHAR_SEL_SCREEN_TEXT+2
	STA	$FB
	LDA	#>CHAR_SEL_SCREEN_TEXT+2
	STA	$FC
	LDA	#<CHAR_SEL_SCREEN_COLOR+2
	STA	$FD
	LDA	#>CHAR_SEL_SCREEN_COLOR+2
	STA	$FE
	JSR	SCREENCOPY
	JSR	CHAR_SEL_CURSOR_PLOT

CHAR_SEL_KEYWAIT:
	JSR	$FFE4
	CMP	#$00
	BEQ	CHAR_SEL_KEYWAIT
	CMP	#$91	;CURSOR UP
	BNE	CSK01
	JMP	CHAR_SEL_KEY_UP
CSK01:
	CMP	#$11	;CURSOR DOWN
	BNE	CSK02
	JMP	CHAR_SEL_KEY_DOWN
CSK02:	
	CMP	#$9D	;CURSOR LEFT
	BNE CSK03
	JMP	CHAR_SEL_KEY_LEFT
CSK03:
	CMP	#$1D	;CURSOR RIGHT
	BNE CSK04
	JMP	CHAR_SEL_KEY_RIGHT
CSK04:
	CMP	#$0D	;RETURN
	BNE CSK05
	JMP	CHAR_SEL_FINISHED
CSK05:
	CMP	#$31	;1-KEY
	BNE CSK06
	JSR	SWBANK1
	JSR	CHAR_SEL_CURSOR_PLOT
	JMP	CHAR_SEL_KEYWAIT
CSK06:
	CMP	#$32	;2-KEY
	BNE CSK07
	JSR	SWBANK2
	JSR	CHAR_SEL_CURSOR_PLOT
	JMP	CHAR_SEL_KEYWAIT
CSK07:
	JMP	CHAR_SEL_KEYWAIT

CHAR_SEL_KEY_UP:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	CHAR_SEL_Y
	CMP	CHAR_SEL_MIN_Y
	BEQ	CSKU1
	DEC	CHAR_SEL_Y
CSKU1:
	JSR	CHAR_SEL_CURSOR_PLOT	
	JMP	CHAR_SEL_KEYWAIT

CHAR_SEL_KEY_DOWN:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	CHAR_SEL_Y
	CMP	CHAR_SEL_MAX_Y
	BEQ	CSKD1
	INC	CHAR_SEL_Y
CSKD1:
	JSR	CHAR_SEL_CURSOR_PLOT	
	JMP	CHAR_SEL_KEYWAIT

CHAR_SEL_KEY_LEFT:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	CHAR_SEL_X
	CMP	CHAR_SEL_MIN_X
	BEQ	CSKL1
	DEC	CHAR_SEL_X
CSKL1:
	JSR	CHAR_SEL_CURSOR_PLOT	
	JMP	CHAR_SEL_KEYWAIT

CHAR_SEL_KEY_RIGHT:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	CHAR_SEL_X
	CMP	CHAR_SEL_MAX_X
	BEQ	CSKR1
	INC	CHAR_SEL_X
CSKR1:
	JSR	CHAR_SEL_CURSOR_PLOT	
	JMP	CHAR_SEL_KEYWAIT

CHAR_SEL_CURSOR_PLOT:
	LDA	CHAR_SEL_Y
	STA	VERA_HI
	LDA	CHAR_SEL_X
	ASL		;MULT BY 2
	CLC
	ADC	#01		;ADD ONE FOR COLORSPACE
	STA	VERA_LO
	LDA	CHAR_SEL_COLOR
	STA	VERA_RW
	RTS

CHAR_SEL_CURSOR_UNPLOT:
	LDA	CHAR_SEL_Y
	STA	VERA_HI
	LDA	CHAR_SEL_X
	ASL		;MULT BY 2
	CLC
	ADC	#01		;ADD ONE FOR COLORSPACE
	STA	VERA_LO
	LDA	CHAR_SEL_NORM
	STA	VERA_RW
	RTS

SWBANK1:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	#07
	STA	CHAR_SEL_MIN_Y
	LDA	#22
	STA	CHAR_SEL_MAX_Y
	LDA	#0
	STA	CHAR_SEL_MIN_X
	LDA	#19
	STA	CHAR_SEL_MAX_X
	LDA	#97
	STA	CHAR_SEL_COLOR
	LDA	#12
	STA	CHAR_SEL_NORM
	LDA	#10
	STA	CHAR_SEL_X
	LDA	#14
	STA	CHAR_SEL_Y
	RTS
SWBANK2:
	JSR	CHAR_SEL_CURSOR_UNPLOT
	LDA	#09 
	STA	CHAR_SEL_MIN_Y
	LDA	#23
	STA	CHAR_SEL_MAX_Y
	LDA	#23
	STA	CHAR_SEL_MIN_X
	LDA	#38
	STA	CHAR_SEL_MAX_X
	LDA	#01
	STA	CHAR_SEL_COLOR
	LDA	#06
	STA	CHAR_SEL_NORM
	LDA	#30
	STA	CHAR_SEL_X
	LDA	#15
	STA	CHAR_SEL_Y
	RTS

CHAR_SEL_FINISHED:
	LDA	CHAR_SEL_Y
	STA	VERA_HI
	LDA	CHAR_SEL_X
	ASL		;MULT BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	PCHAR
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	JSR	MAIN_CURSOR_PLOT
	RTS
	
; The following routing is the Pixel-Draw screen
; which allows the user to draw using an 80x50 matrix
; of PETSCII block characters. it is accessed by
; pressing F3.

PIXEL_DRAW_SCREEN:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	XLOC	;convert coordinates from regular screen to 
	ASL			;the pixel-draw matrix so that cursor shows
	STA	PX		;up around the same place.
	LDA	YLOC
	ASL	
	STA	PY
	JSR	POSTMOVE

PXGETKEYBOARD:
	JSR	PXCURSOR
	JSR	$FFE4
	CMP	#$00
	BEQ	PXGETKEYBOARD
	CMP	#138	; F4
	BNE	PXKEY01
	JSR	PREMOVE
	JSR	COLOR_SCREEN
	JSR	POSTMOVE
PXKEY01	CMP	#$85	;F1-KEY
	BNE	PXKEY02
	JSR	PREMOVE
	JSR	MAIN_CURSOR_PLOT
	JMP	MAIN_DRAW_SCREEN
PXKEY02	CMP	#$91	;CURSOR UP
	BNE	PXKEY03
	JSR	PXUP
	JMP	PXGETKEYBOARD
PXKEY03	CMP	#$11	;CURSOR DOWN
	BNE	PXKEY04
	JSR	PXDOWN
	JMP	PXGETKEYBOARD
PXKEY04	CMP	#$9D	;CURSOR LEFT
	BNE	PXKEY05
	JSR	PXLEFT
	JMP	PXGETKEYBOARD
PXKEY05	CMP	#$1D	;CURSOR RIGHT
	BNE	PXKEY06	
	JSR	PXRIGHT
	JMP	PXGETKEYBOARD
PXKEY06	CMP	#$20	;SPACE
	BNE	PXKEY07
	JSR	PIXELPLOT
	LDA	PCHAR
	STA	CHRTEMP
	LDA	SELCOL
	STA	COLTEMP
	JMP	PXGETKEYBOARD
PXKEY07	CMP	#$14	;BACKSPACE
	BNE	PXKEY08
	JSR	PIXELUNPLOT
	JMP	PXGETKEYBOARD
PXKEY08	CMP	#134	;F3
	BNE	PXKEY09
	;JMP	TYPINGMODESCREEN
PXKEY09
	JMP	PXGETKEYBOARD

PXRIGHT:
	LDA	SCR_SIZE_X
	ASL	;MULTIPLY BY 2
	SEC
	SBC	#1
	CMP	PX
	BEQ	PXR01
	JSR	PREMOVE
	INC	PX
	JSR	CONVPXPY
	JSR	POSTMOVE
PXR01	RTS

PXLEFT:
	LDA	PX
	CMP	#$00
	BEQ	PXL01
	JSR	PREMOVE
	DEC	PX
	JSR	CONVPXPY
	JSR	POSTMOVE
PXL01	RTS

PXDOWN:
	LDA	SCR_SIZE_Y
	ASL	;MULTIPLY BY 2
	SEC
	SBC	#1
	CMP	PY
	BEQ	PXD01
	JSR	PREMOVE
	INC	PY
	JSR	CONVPXPY
	JSR	POSTMOVE
PXD01	RTS

PXUP:
	LDA	PY
	CMP	#$00
	BEQ	PXU01
	JSR	PREMOVE
	DEC	PY
	JSR	CONVPXPY
	JSR	POSTMOVE
PXU01	RTS

;The following routine blinks the cursor for pixel mode. However
;it is a carry over from the C64 version and needs to be re-written
;to use the VIA timers instead of a loop like it does now.

PXCURSOR:
	INC	CRXTIMER		;TIMING ROUTINE
	LDA	#$00
	CMP	CRXTIMER
	BNE	PXCR10
	INC	CRXTIM2
	LDA	#$04
	CMP	CRXTIM2
	BNE	PXCR10
	LDA	#$00
	STA	CRXTIM2
	
	LDA	PXCRST		;TIME TO DO SOMETHING
	CMP	#$01		; check cursor state
	BNE	PXCR01
	LDA	#$00
	STA	PXCRST		;TURN CURSOR ON
	JSR	PIXELCRPLOT
	JMP	PXCR10
PXCR01	LDA	#$01
	STA	PXCRST
	JSR	PIXELCRUNPLOT	;TURN CURSOR OFF
PXCR10	RTS

;The following routing converts the pixel coordinates
;into regular 40x25 text coordinates.

CONVPXPY:
	LDA	PX
	LSR			;divide by 2
	STA	XLOC
	LDA	PY
	LSR			;divide by 2
	STA	YLOC	
	RTS

; The following routine takes the coordinates in 
; PX and PY and plots a pixel on the screen.

PIXELPLOTFIND:
	JSR	CONVPXPY
	JSR	GETCHAR		;find out what char is already there	
	LDX	#$00	
PP01	LDA	PIXELMAP,X
	CMP	PCHAR
	BEQ	PP02
	INX
	CPX 	#$00
	BEQ	PP02
	JMP	PP01
PP02	STX	PIXEL
	LDA	PX
	AND	#%00000001
	CMP	#%00000001
	BEQ	PP03
	LDA	#%00000010
	JMP	PP04
PP03	LDA	#%00000001
PP04	STA	PIXEL2
	LDA	PY
	AND	#%00000001
	CMP	#%00000001
	BEQ	PP05
	ASL	PIXEL2
	ASL	PIXEL2	
PP05	RTS

PX	!BYTE	$00	; X-Location (0-79)
PY	!BYTE	$00	; Y-Location (0-49)
PIXEL	!BYTE	$00	; CURRENT 4-BIT PIXEL
PIXEL2	!BYTE	$00	; TEMP

PIXELPLOT:	
	JSR	PIXELPLOTFIND
	LDA	PIXEL2
	ORA	PIXEL
	TAX
	LDA	PIXELMAP,X
	STA	PCHAR
	STA	CHRTEMP
	LDA	SELCOL
	STA	PCOL
	JSR	PLOTCHAR
	RTS

PIXELUNPLOT:
	JSR	PIXELPLOTFIND
	LDA	PIXEL2
	EOR	#%11111111
	AND	PIXEL
	TAX
	LDA	PIXELMAP,X
	STA	PCHAR
	STA	CHRTEMP
	LDA	SELCOL
	STA	PCOL
	JSR	PLOTCHAR
	RTS

PIXELCRPLOT:	
	JSR	PIXELPLOTFIND
	LDA	PIXEL2
	ORA	PIXEL
	TAX
	LDA	PIXELMAP,X
	STA	PCHAR
	LDA	SELCOL
	STA	PCOL
	JSR	PLOTCHAR
	RTS

PIXELCRUNPLOT:
	JSR	PIXELPLOTFIND
	LDA	PIXEL2
	EOR	#%11111111
	AND	PIXEL
	TAX
	LDA	PIXELMAP,X
	STA	PCHAR
	LDA	SELCOL
	STA	PCOL
	JSR	PLOTCHAR
	RTS
	
; The following routine plots a character on the screen
; based on what is stored in XLOC, YLOC, PCHAR, AND PCOL

PLOTCHAR:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDA	YLOC
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULTIPLY BY 2
	STA	VERA_LO
	LDA	PCHAR
	STA	VERA_RW	;WRITE CHAR
	LDA	PCOL
	STA	VERA_RW	;WRITE COLOR
	RTS	
	
; The following routine does the exact opposite
; in that it gets the character and color from 
; the screen and places them in PCAR and PCOL

GETCHAR:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDA	YLOC
	STA	VERA_HI
	LDA	XLOC
	ASL		;MULTIPLY BY 2
	STA	VERA_LO
	LDA	VERA_RW
	STA	PCHAR
	LDA	VERA_RW
	STA	PCOL
	RTS
	
POSTMOVE:
	JSR	GETCHAR
	LDA	PCHAR
	STA	CHRTEMP
	LDA	PCOL
	STA	COLTEMP
	RTS

PREMOVE:
	LDA	CHRTEMP
	STA	PCHAR
	LDA	COLTEMP
	STA	PCOL
	JSR	PLOTCHAR
	RTS

;The following routine clears the entire 80x60 screen
;and sets the color attributes to white on black.

CLEAR_SCREEN:
	LDA	#%00010000	;SET INCREMENT TO 1
	STA	VERA_INC
	LDA	#00			;SET STARTING POINT TO ZERO
	LDX	#0
	LDY	#0
CLSC01:
	STY	VERA_HI
	LDA	#00
	STA	VERA_LO
CLSC02:
	LDA	#32			;SPACE
	STA	VERA_RW
	LDA	#01			;WHITE ON BLACK
	STA	VERA_RW
	INX
	CPX	#80
	BNE	CLSC02
	LDX	#0
	INY
	CPY	#60
	BNE	CLSC01
	RTS

COPY_SCREEN_TO_BUFFER:
	LDA	#%00010000	;INCREMENT SET TO ONE
	STA	VERA_INC
	LDX	#00
	LDY	#00
	LDA	#<SCREEN_BUFFER
	STA	$FB
	LDA	#>SCREEN_BUFFER
	STA	$FC
CSTB01:
	LDA	#00
	STA	VERA_LO
	STX	VERA_HI
CSTB02:
	LDA	VERA_RW
	STA	($FB),Y
	INY
	CPY	COPY_WIDTH
	BNE	CSTB02
	LDY	#00
	LDA	$FB
	CLC
	ADC	COPY_WIDTH
	STA	$FB
	LDA	$FC
	ADC	#00
	STA	$FC
	INX
	CPX	COPY_HEIGHT
	BNE	CSTB01
	RTS

COPY_BUFFER_TO_SCREEN:
	LDA	#%00010000	;INCREMENT SET TO ONE
	STA	VERA_INC
	LDX	#00
	LDY	#00
	LDA	#<SCREEN_BUFFER
	STA	$FB
	LDA	#>SCREEN_BUFFER
	STA	$FC
CBTS01:
	LDA	#0
	STA	VERA_LO
	STX	VERA_HI
CBTS02:
	LDA	($FB),Y
	STA	VERA_RW
	INY
	CPY	COPY_WIDTH
	BNE	CBTS02
	LDY	#$00
	LDA	$FB
	CLC
	ADC	COPY_WIDTH
	STA	$FB
	LDA	$FC
	ADC	#00
	STA	$FC
	INX
	CPX	COPY_HEIGHT
	BNE	CBTS01
	RTS

HELP_SCREEN:
	JSR	MAIN_CURSOR_UNPLOT
	JSR	COPY_SCREEN_TO_BUFFER
	JSR	SET40
	
;This routine is a bit unique because I had to design the
;character pick screen from the C64 version of PetDraw which
;stores the data in a very different way.  So this routine
;converts it while simultaneously displays it on screen.	
	
HS01:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDY	#00
	STY	VERA_HI
	STY	VERA_LO		;SET STARTING POSITION
	LDA	#<HELP_SCREEN_TEXT
	STA	$FB
	LDA	#>HELP_SCREEN_TEXT
	STA	$FC
	LDA	#<HELP_SCREEN_COLOR
	STA	$FD
	LDA	#>HELP_SCREEN_COLOR
	STA	$FE
	JSR	SCREENCOPY
HS05:
	JSR	$FFE4
	CMP	#$00
	BEQ	HS05
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	JSR	MAIN_CURSOR_PLOT
	RTS

SCREENCOPY:
	LDX	#$00
	LDY	#$00
HS04:
	LDA	($FB),Y
	STA	VERA_RW
	LDA	($FD),Y
	AND	#%00001111	;REMOVE UPPER 4 BITS OF COLOR DATA
	STA	VERA_RW
	INY
	CPY	#40
	BNE	HS04
	LDY	#00
	CLC
	LDA	$FB		;INCREASE ORIGIN TEXT BY 40 CHARACTERS
	ADC	#40
	STA	$FB
	LDA	$FC
	ADC	#$00
	STA $FC
	CLC			;INCREASE ORIGIN COLOR BY 40 BYTES
	LDA	$FD
	ADC	#40
	STA	$FD
	LDA	$FE
	ADC	#$00
	STA $FE
	INX
	STX	VERA_HI	;SET NEW LINE ON VIDEO RAM
	LDA	#$00
	STA	VERA_LO
	CPX	#25
	BNE	HS04
	RTS

COLOR_SCREEN:
	JSR	COPY_SCREEN_TO_BUFFER
	JSR	SET40
CS01:
	LDA	SELCOL	;GET CURRENT COLOR
	AND	#%00001111	;Strip top bits to get FG color
	STA	COLSEL_FG
	LDA	SELCOL	;GET CURRENT COLOR
	AND	#%11110000	;Strip lower bits to get BG color
	LSR
	LSR
	LSR
	LSR
	STA	COLSEL_BG
	
;This routine is a bit unique because I had to design the
;character pick screen from the C64 version of PetDraw which
;stores the data in a very different way.  So this routine
;converts it while simultaneously displays it on screen.	
	
CS02:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDY	#00
	STY	VERA_HI
	STY	VERA_LO		;SET STARTING POSITION
	LDA	#<COLOR_SCREEN_TEXT+2
	STA	$FB
	LDA	#>COLOR_SCREEN_TEXT+2
	STA	$FC
	LDA	#<COLOR_SCREEN_COLOR+2
	STA	$FD
	LDA	#>COLOR_SCREEN_COLOR+2
	STA	$FE
	JSR	SCREENCOPY
	JSR COLBANKHILITE
	JSR	FGCOLORHILITE
	JSR	BGCOLORHILITE
	JSR	SAMPLE_COLOR_DISPLAY

CS05:
	JSR	$FFE4
	CMP	#$00
	BEQ	CS05
	CMP	#$91	;CURSOR UP
	BNE	CS06
	JMP	COLOR_UP
CS06:
	CMP	#$11	;CURSOR DOWN
	BNE	CS07
	JMP	COLOR_DOWN
CS07:	
	CMP	#$9D	;CURSOR LEFT
	BNE CS08
	JMP	COLOR_LEFT
CS08:
	CMP	#$1D	;CURSOR RIGHT
	BNE CS09
	JMP	COLOR_RIGHT
CS09:
	CMP	#$0D	;RETURN
	BNE	CS10
	JSR	COLOR_CONVERT
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	RTS
CS10:
	JMP	CS05

COLOR_CONVERT:
	LDA	COLSEL_BG
	ASL
	ASL
	ASL
	ASL
	ORA	COLSEL_FG
	STA	SELCOL
	STA	PCOL
	RTS

COLOR_UP:
	LDA	COLSEL_BANK
	CMP	#00
	BNE	CU02:
	LDA	COLSEL_FG
	CMP	#0
	BEQ	CU01:
	JSR	FGCOLORHILITE	;UNHILITE SELECTION
	DEC	COLSEL_FG
	JSR	FGCOLORHILITE	;RE-HILITE SELECTION
	JSR	SAMPLE_COLOR_DISPLAY
	JMP	CS05
CU01:
	JMP	CS05
CU02:
	LDA	COLSEL_BG
	CMP	#0
	BEQ	CU01:
	JSR	BGCOLORHILITE	;UNHILITE SELECTION
	DEC	COLSEL_BG
	JSR	BGCOLORHILITE	;RE-HILITE SELECTION
	JSR	SAMPLE_COLOR_DISPLAY
	JMP	CS05

COLOR_DOWN:
	LDA	COLSEL_BANK
	CMP	#00
	BNE	CD02:
	LDA	COLSEL_FG
	CMP	#15
	BEQ	CD01:
	JSR	FGCOLORHILITE	;UNHILITE SELECTION
	INC	COLSEL_FG
	JSR	FGCOLORHILITE	;RE-HILITE SELECTION
	JSR	SAMPLE_COLOR_DISPLAY
	JMP	CS05
CD01:
	JMP	CS05
CD02:
	LDA	COLSEL_BG
	CMP	#15
	BEQ	CD01:
	JSR	BGCOLORHILITE	;UNHILITE SELECTION
	INC	COLSEL_BG
	JSR	BGCOLORHILITE	;RE-HILITE SELECTION
	JSR	SAMPLE_COLOR_DISPLAY
	JMP	CS05

COLOR_LEFT:
	JSR	COLBANKHILITE	;UNHILITE CORRENT SELECTION
	LDA	#0
	STA	COLSEL_BANK		;SET LEFT SIDE
	JSR	COLBANKHILITE	;RE-HILITE CORRENT SELECTION		
	JMP	CS05
COLOR_RIGHT:
	JSR	COLBANKHILITE	;UNHILITE CORRENT SELECTION
	LDA	#1
	STA	COLSEL_BANK		;SET LEFT SIDE
	JSR	COLBANKHILITE	;RE-HILITE CORRENT SELECTION		
	JMP	CS05

;This routine highlights the currently selected FG color
;on the color picker screen 

FGCOLORHILITE:
	LDA	#%00000000	;INCREMENT DISABLE
	STA	VERA_INC
	LDA	COLSEL_FG
	CLC
	ADC	#08
	STA	VERA_HI
	LDA	#09
	STA	VERA_LO
	JSR	TEXTINVERT
	RTS

;This routine highlights the currently selected BG color
;on the color picker screen 

BGCOLORHILITE:
	LDA	#%00000000	;INCREMENT DISABLE
	STA	VERA_INC
	LDA	COLSEL_BG
	CLC
	ADC	#08
	STA	VERA_HI
	LDA	#53
	STA	VERA_LO
	JSR	TEXTINVERT
	RTS

;This routine highlights the currently selected bank on the
;color picker screen (foreground or background)	

COLBANKHILITE:
	LDA	#%00000000	;INCREMENT DISABLE
	STA	VERA_INC
	LDA	#6
	STA	VERA_HI
	LDA	COLSEL_BANK
	CMP	#0
	BNE	CBHL1
	LDA	#9		;"FOREGROUND" LOCATED AT X=4 Y=6
	STA	VERA_LO
	JMP	CBHL2
CBHL1:
	LDA	#53		;"FOREGROUND" LOCATED AT X=28 Y=6
	STA	VERA_LO
CBHL2:
	JSR	TEXTINVERT
	RTS

;The following routine inverts 10 characters, but it needs
;to have the starting position set for VERA_LO and VERA_HI
;first, and also needs VERA_INC set to 0.

TEXTINVERT:	
	LDX	#0
THL01:
	LDA	VERA_RW	;GET COLOR
	STA CHRTEMP
	ASL			;INVERT COLORS
	ASL
	ASL
	ASL
	LSR	CHRTEMP
	LSR	CHRTEMP
	LSR	CHRTEMP
	LSR	CHRTEMP
	ORA	CHRTEMP
	STA	VERA_RW
	INC	VERA_LO
	INC	VERA_LO
	INX
	CPX	#10
	BNE	THL01
	RTS

;The following routine sets the colors for the
;sample figure in the middle of the color select
;screen.

SAMPLE_COLOR_DISPLAY:
	JSR	COLOR_CONVERT
	LDA	#%00000000	;NO INCREMENT
	STA	VERA_INC	;START POSITION X=16 Y=12
	LDY	#12
SCD01:
	LDA	#33
	STA	VERA_LO
	STY	VERA_HI
	LDA	SELCOL
	LDX	#00
SCD02:
	STA	VERA_RW
	INC	VERA_LO
	INC	VERA_LO
	INX
	CPX	#8
	BNE	SCD02
	INY
	CPY	#20
	BNE	SCD01
	RTS

LOAD_SAVE_MENU:
	JSR	COPY_SCREEN_TO_BUFFER
	JSR	SET40
	LDA	#1	;WHITE
	STA	$0286 	;CURRENT COLOR
	JSR	CLEAR_SCREEN
	LDY	#0
LSM01:
	LDA	LOAD_SAVE_TEXT,Y
	JSR	$FFD2	;CHROUT
	INY
	CPY	#72
	BNE LSM01
	JSR	DISPLAY_FILENAME
	JSR	NAME_TYPE
	JMP	LOAD_SAVE_SELECT

LOAD_SAVE_TEXT:
	!BYTE 19	;HOME
	!SCR "FILE NAME:"
	!BYTE 13,32,32,32,32,32,32,32,32,32,32	
	!BYTE 163,163,163,163,163,163,163,163	;UNDERLINE
	!BYTE 163,163,163,163,163,163,163,163	;UNDERLINE
	!BYTE 13
	!SCR "DEVICE# 01"
	!BYTE 13,13
	!SCR " SAVE   LOAD   CANCEL"

LOAD_SAVE_SELECT:
	LDA	#00
	STA	XTEMP
	JSR	DISPLAY_LS_SELECT
LSS1:
	JSR	$FFE4
	CMP	#$00
	BEQ	LSS1
	CMP	#$9D	;CURSOR LEFT
	BNE	LSS5
	LDA	XTEMP
	CMP	#00
	BEQ	LSS1
	DEC	XTEMP
	JSR	DISPLAY_LS_SELECT
	JMP	LSS1
LSS5:
	CMP	#$1D	;CURSOR RIGHT
	BNE	LSS8
	LDA	XTEMP
	CMP	#02
	BEQ	LSS1
	INC	XTEMP
	JSR	DISPLAY_LS_SELECT
	JMP	LSS1
LSS8:
	CMP	#13		;RETURN
	BNE	LSS10
	JMP	SEL_FINISHED
LSS10:
	JMP	LSS1

SEL_FINISHED:
	LDA	XTEMP
	CMP	#0	;SAVE
	BNE	SF05
	JSR	SAVE_ROUTINE
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	RTS
SF05:
	CMP	#1	;LOAD
	BNE	SF08
	JSR LOAD_ROUTINE
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	RTS
SF08:
	CMP	#2	;CANCEL
	BNE	SF10
	JSR	SET_MODE
	JSR	COPY_BUFFER_TO_SCREEN
	RTS
SF10:
	JMP	LSS1

DISPLAY_LS_SELECT:
	LDA	#%00100000	;INCREMENT BY 2
	STA	VERA_INC
	LDA	#04	;5TH ROW FROM TOP
	STA	VERA_HI
	LDA	#1	;LEFT MOST COLUMN COLOR ATTRIBUTE
	STA	VERA_LO
	LDA	#06	;WHITE ON BLACK
	LDY	#00
DLS01:
	STA	VERA_RW
	INY
	CPY	#22
	BNE	DLS01
	;HILIGHT SELECTED UNIT
	LDY	XTEMP
	LDA	LSMENU,Y
	STA	VERA_LO
	LDY	#0
	LDA	#97;	WHITE TEXT ON BLUE
DLS02:
	STA	VERA_RW
	INY
	CPY	#6
	BNE	DLS02
	RTS
LSMENU	!BYTE	1,15,31

DISPLAY_FILENAME:
	LDA	#%00010000	;INCREMENT BY 1
	STA	VERA_INC
	LDA	#00
	STA	VERA_HI
	LDA	#20	;STARTING SCREEN LOCATION
	STA	VERA_LO
	LDY	#00
	LDA	NAME_LENGTH
	CMP	#00	;If name is 0 length, skip to cursor
	BEQ FLOOP3
FLOOP1:	
	LDA	FILE_NAME,Y
	JSR	PETSCII_TO_SCREENCODE
	STA	VERA_RW
	LDA	#14	;LIGHT BLUE
	STA	VERA_RW
	INY
	CPY	NAME_LENGTH
	BNE	FLOOP1	
	;NOW ADD CURSOR
FLOOP3:
	LDA	#32
	STA	VERA_RW
	LDA	#224	;INVERTED BLUE
	STA	VERA_RW
FLOOP2:
	LDA	#32;SPACE
	STA	VERA_RW
	LDA	#14	;BLUE
	STA	VERA_RW
	INY
	CPY	#17
	BNE	FLOOP2
	RTS

NAME_TYPE:
	JSR	$FFE4
	CMP	#$00
	BEQ	NAME_TYPE
	CMP	#13	;RETURN
	BNE	NT01
	LDA	NAME_LENGTH
	CMP	#00
	BEQ	NAME_TYPE
	RTS
NT01:
	CMP	#20	;BACKSPACE
	BNE	NT02
	LDA	NAME_LENGTH
	CMP	#0
	BEQ	NAME_TYPE
	DEC	NAME_LENGTH
	JSR	DISPLAY_FILENAME
	JMP	NAME_TYPE	
NT02:
	CMP	#47	;IS IT GREATER THAN CHR$(47)
	BCS	NT03
	JMP	NAME_TYPE
NT03:
	CMP	#91	;IS IT GREATER THAN CHR$(91)
	BCC	NT04
	JMP	NAME_TYPE
NT04:	
	LDY	NAME_LENGTH
	CPY	#16
	BNE	NT05
	JMP	NAME_TYPE	
NT05:
	STA	FILE_NAME,Y
	INY
	STY	NAME_LENGTH
	JSR	DISPLAY_FILENAME
	JMP	NAME_TYPE

PETSCII_TO_SCREENCODE:
	cmp	#$ff
	bne	.l1
	lda	#$5e
	rts
.l1: 	pha
	lsr
	lsr 
	lsr
	lsr
	lsr
	tax
	pla
	clc
	adc	table_p2s,x
	rts
table_p2s: !byte 128,0,192,224,64,192,128,128

SCREENCODE_TO_PETSCII:
	pha
	lsr
	lsr 
	lsr
	lsr
	lsr
	tax
	pla
	clc
	adc table_s2p,x
	rts
table_s2p: !byte 64,0,128,64,128,192,192,0

; The following routine loads a file from disk

LOAD_ROUTINE:	
	LDA	NAME_LENGTH
	LDX	#<FILE_NAME
	LDY	#>FILE_NAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$01	;DRIVE 1
	LDY	#$00
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDX	#<SCREEN_BUFFER
	LDY	#>SCREEN_BUFFER
	LDA	#$00
	JSR	$FFD5	;LOAD FILE A=0 FOR LOAD X/Y=LOAD ADDRESS
	RTS

; The following routine saves a file to disk

SAVE_ROUTINE:
	LDY	TEXT_MODE	;FIND OUT SIZE OF FILE
	LDA	FSIZE_L,Y
	STA	SHIFT_TEMP1
	LDA	FSIZE_H,Y
	STA	SHIFT_TEMP2
	
	LDA	NAME_LENGTH
	LDX	#<FILE_NAME
	LDY	#>FILE_NAME
	JSR	$FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
	LDA	#$02
	LDX	#$01	;DRIVE 1
	LDY	#$02
	JSR	$FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
	LDA	#<SCREEN_BUFFER	
	STA	$FB
	LDA	#>SCREEN_BUFFER
	STA	$FC
	LDA	#$FB	;START LOCATION STORED AT $FB
	LDX	SHIFT_TEMP1	;END LOCATION LOW-BYTE
	LDY	SHIFT_TEMP2	;END LOCATION HIGH-BYTE
	JSR	$FFD8	;SAVE FILE A=ADDRESS ZEROPAGE POINTER, X/Y= END OF ADDRESS+1
	RTS

SETUP_MENU:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	#160
	STA	COPY_WIDTH
	LDA	#30
	STA	COPY_HEIGHT
	JSR	COPY_SCREEN_TO_BUFFER
	LDA	#1	;WHITE
	STA	$0286 	;CURRENT COLOR
	JSR	CLEAR_SCREEN
	LDY	#0
SM01:
	LDA	SETUP_TEXT,Y
	JSR	$FFD2	;CHROUT
	INY
	CPY	#73
	BNE SM01
	JSR	CALC123
	JSR	HILITE_MODE
SM10:
	JSR	$FFE4
	CMP	#$00
	BEQ	SM10
	CMP	#$91	;CURSOR UP
	BNE	SM15
	LDA	TEXT_MODE
	CMP	#00
	BEQ	SM10
	JSR	UNHILITE_MODE
	DEC	TEXT_MODE
	JSR	HILITE_MODE
	JSR	SET_MODE
	JMP	SM10
SM15:
	CMP	#$11	;CURSOR DOWN
	BNE	SM20
	LDA	TEXT_MODE
	CMP	#5
	BEQ	SM10
	JSR	UNHILITE_MODE
	INC	TEXT_MODE
	JSR	HILITE_MODE
	JSR	SET_MODE	
	JMP	SM10
SM20:
	CMP	#13	;RETURN
	BNE	SM10
	LDA	#0
	STA	YLOC	;Need to reposition cursor in case
	STA	XLOC	;moving to small screen size
	JSR	COPY_BUFFER_TO_SCREEN
	LDA	SCR_SIZE_X
	ASL		;MULT BY 2
	STA	COPY_WIDTH
	LDA	SCR_SIZE_Y
	STA	COPY_HEIGHT
	JSR	MAIN_CURSOR_PLOT
	RTS

SET_MODE:
	LDA	#$0F	;BANK 4
	STA	VERA_INC
	LDA	#00
	STA	VERA_HI
	LDA	#$41	;H-SCALE
	STA	VERA_LO
	LDY	TEXT_MODE
	LDA	MODEX,Y
	STA	VERA_RW	
	LDA	#$42	;V-SCALE
	STA	VERA_LO
	LDY	TEXT_MODE
	LDA	MODEY,Y
	STA	VERA_RW	
	LDA	#0	;BANK 0
	STA	VERA_INC
	LDA	SIZEX,Y
	STA	SCR_SIZE_X
	LDA	SIZEY,Y
	STA	SCR_SIZE_Y
	RTS

MODEX	!BYTE 128,128,64,64,32,32
MODEY	!BYTE 128,64,128,64,64,32
SIZEX	!BYTE 80,80,40,40,20,20
SIZEY	!BYTE 60,30,60,30,30,15
;FSIZE_H	!BYTE $25,$12,$12,$09,$04,$02
;FSIZE_L	!BYTE $80,$C0,$C0,$60,$B0,$58

FSIZE_L	!BYTE <SCREEN_BUFFER+9600
		!BYTE <SCREEN_BUFFER+4800
		!BYTE <SCREEN_BUFFER+4800
		!BYTE <SCREEN_BUFFER+2400
		!BYTE <SCREEN_BUFFER+1200
		!BYTE <SCREEN_BUFFER+600
FSIZE_H	!BYTE >SCREEN_BUFFER+9600
		!BYTE >SCREEN_BUFFER+4800
		!BYTE >SCREEN_BUFFER+4800
		!BYTE >SCREEN_BUFFER+2400
		!BYTE >SCREEN_BUFFER+1200
		!BYTE >SCREEN_BUFFER+600



SET40:
LDA	#4	;BANK 4
	STA	VERA_INC
	LDA	#00
	STA	VERA_HI
	LDA	#$41	;H-SCALE
	STA	VERA_LO
	LDA	#64
	STA	VERA_RW	
	LDA	#$42	;V-SCALE
	STA	VERA_LO
	LDA	#64
	STA	VERA_RW	
	LDA	#0	;BANK 0
	STA	VERA_INC
	RTS

CALC123:
	LDA	#%00100000	;INCREMENT 2
	STA	VERA_INC
	LDA	#1
	STA	VERA_LO
	LDA	TEXT_MODE
	CLC
	ADC	#2
	STA	VERA_HI
	RTS

HILITE_MODE:
	JSR	CALC123
	LDA	#97	;WHITE TEXT ON BLUE
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	RTS

UNHILITE_MODE:
	JSR	CALC123
	LDA	#14	;L.BLUE TEXT ON BLACK
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	STA	VERA_RW
	RTS

SETUP_TEXT:
	!BYTE 19	;HOME
	!SCR	"SCREEN SIZE"
	!BYTE	13
	!BYTE 	163,163,163,163,163,163,163,163,163,163,163	;UNDERLINE
	!BYTE	13,154	;return and then light blue
	!SCR	"80 X 60"
	!BYTE	13
	!SCR	"80 X 30"
	!BYTE	13
	!SCR	"40 X 60"
	!BYTE	13
	!SCR	"40 X 30"
	!BYTE	13
	!SCR	"20 X 30"
	!BYTE	13
	!SCR	"20 X 15"

TYPE_MODE:
	JSR	$FFE4
	CMP	#$00
	BEQ	TYPE_MODE
	CMP	#$91	;CURSOR UP
	BNE	TM01
	JSR	MAIN_KEY_UP
	JMP	TYPE_MODE
TM01:
	CMP	#$11	;CURSOR DOWN
	BNE	TM02
	JSR	MAIN_KEY_DOWN
	JMP	TYPE_MODE
TM02:	
	CMP	#$9D	;CURSOR LEFT
	BNE TM03
	JSR	MAIN_KEY_LEFT
	JMP	TYPE_MODE
TM03:
	CMP	#$1D	;CURSOR RIGHT
	BNE TM04
	JSR	MAIN_KEY_RIGHT
	JMP	TYPE_MODE
TM04:
	CMP	#$0D	;RETURN
	BNE TM05
	JSR	TYPE_RETURN
	JMP	TYPE_MODE
TM05:
	CMP	#138	;F4-KEY
	BNE	TM07
	JSR	COLOR_SCREEN
	JMP	TYPE_MODE
TM07:
	CMP	#137	;F2-KEY (PIXEL DRAW MODE)
	BNE	TM08
	JMP	PIXEL_DRAW_SCREEN
TM08:
	CMP	#$85	;F1-KEY
	BNE	TM09
	JMP	MAIN_DRAW_SCREEN
TM09:
	CMP	#20	;BACKSPACE
	BNE	TM20
	JSR	TYPE_BACKSPACE
	JMP	TYPE_MODE
TM20:
	JSR	PETSCII_TO_SCREENCODE
	STA	PCHAR
	JSR	MAIN_CURSOR_UNPLOT
	LDA	SELCOL
	STA PCOL
	JSR	PLOTCHAR
	LDA	SCR_SIZE_X
	SEC
	SBC	#1
	CMP	XLOC
	BEQ	TM21		
	INC	XLOC
TM21:
	JSR	MAIN_CURSOR_PLOT
	JMP	TYPE_MODE

TYPE_RETURN:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	#0
	STA	XLOC
	LDA	SCR_SIZE_Y
	SEC
	SBC	#1
	CMP	YLOC
	BEQ	TR01
	INC	YLOC
TR01:
	JSR	MAIN_CURSOR_PLOT
	RTS

TYPE_BACKSPACE:
	JSR	MAIN_CURSOR_UNPLOT
	LDA	XLOC
	CMP	#0
	BEQ	TB01
	DEC	XLOC
	LDA	#32	;SPACE
	STA	PCHAR
	JSR	PLOTCHAR
TB01:
	JSR	MAIN_CURSOR_PLOT
	RTS

XLOC	!BYTE	$00	;X Coordinate (0-39)
YLOC	!BYTE	$00	;Y Coordinate (0-24)
PCHAR	!BYTE	$00	;Character (0-255)
PCOL	!BYTE	$00	;Color (0-15)
SELCHAR	!BYTE	$00	;SELECTED CHAR
SELCOL	!BYTE	$01	;SELECTED COLOR
XTEMP	!BYTE	$00
YTEMP	!BYTE	$00
CHRTEMP	!BYTE	$20
COLTEMP	!BYTE	$01
PXCRST	!BYTE	$00	;PIXEL CURSOR STATE (0 OR 1)
CRXTIMER !BYTE	$00
CRXTIM2	!BYTE	$00
SCR_SIZE_X	!BYTE	40	;	screen size X (20, 40, or 80)
SCR_SIZE_Y	!BYTE	30 ;	screen size Y (15, 30, or 60)
CHAR_SEL_X	!BYTE	$00 ;	location of character select cursor
CHAR_SEL_Y	!BYTE	$00 ;
CHAR_SEL_MIN_X	!BYTE	23		;These are used to determine the window
CHAR_SEL_MAX_X	!BYTE	38		;or "bank" that the character select screen 
CHAR_SEL_MIN_Y	!BYTE	09		;is currently confined to.
CHAR_SEL_MAX_Y	!BYTE	23		;
CHAR_SEL_COLOR	!BYTE	$01		;Color of char select cursor
CHAR_SEL_NORM	!BYTE	$06		;normal color of char select screen
CRSR_OLD_COL	!BYTE	$00 	;Color before cursor was plotted
COLSEL_FG		!BYTE	$00		;Foreground color selection
COLSEL_BG		!BYTE	$00		;background color selection
COLSEL_BANK		!BYTE	$00		;0=Left 1=right selection
NAME_LENGTH		!BYTE	0		;Length of filename
FILE_NAME		!PET	"                "
DEVICE_NUMBER	!BYTE	$01		;DISK DRIVE DEVICE
TEXT_MODE		!BYTE	03		;DEFAULT 3=40X30
SHIFT_TEMP1		!BYTE	00
SHIFT_TEMP2		!BYTE	00
COPY_WIDTH		!BYTE	80		;Width of screen (IN BYTES) for copy purposes
COPY_HEIGHT		!BYTE	30		;height of copy process
;The following data is for representing each of the
;PETSCII block characters as an 4-bit binary number
;arranged as following:
; 33332222
; 33332222
; 33332222
; 33332222
; 11110000
; 11110000
; 11110000
; 11110000

PIXELMAP:
	!BYTE	$20	
	!BYTE	$6C	
	!BYTE	$7B	
	!BYTE	$62
	!BYTE	$7C
	!BYTE	$E1
	!BYTE	$FF
	!BYTE	$FE
	!BYTE	$7E
	!BYTE	$7F
	!BYTE	$61
	!BYTE	$FC
	!BYTE	$E2
	!BYTE	$FB
	!BYTE	$EC
	!BYTE	$A0

CHAR_SEL_SCREEN_TEXT 	!BINARY "pdcharsel_text.bin"
CHAR_SEL_SCREEN_COLOR	!BINARY "pdcharsel_color.bin"
HELP_SCREEN_TEXT 	!BINARY "x16help_text.bin"
HELP_SCREEN_COLOR	!BINARY "x16help_color.bin"
COLOR_SCREEN_TEXT	!BINARY "pdcolpick_text.bin"
COLOR_SCREEN_COLOR	!BINARY "pdcolpick_color.bin"	

;The last item here is the screen buffer, which is where the edit screen 
;gets copied to when using the character or color select screens.

SCREEN_BUFFER:


